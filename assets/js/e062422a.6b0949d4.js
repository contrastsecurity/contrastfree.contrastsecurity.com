"use strict";(self.webpackChunkcontrast_dev=self.webpackChunkcontrast_dev||[]).push([[8859],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=l(n),m=i,f=p["".concat(c,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(f,s(s({ref:t},u),{},{components:n})):a.createElement(f,s({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1684:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return d}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),s=["components"],o={title:"IAST"},c=void 0,l={unversionedId:"guides/learn-devsec/finding/iast",id:"guides/learn-devsec/finding/iast",title:"IAST",description:"Interactive Application Security Testing is a technique that embeds monitoring into running software to extract security-relevant information. This technique has a high level of accuracy because it simply observes what the runtime does and reports back.",source:"@site/learn/guides/learn-devsec/finding/iast.md",sourceDirName:"guides/learn-devsec/finding",slug:"/guides/learn-devsec/finding/iast",permalink:"/learn/guides/learn-devsec/finding/iast",editUrl:"https://github.com/contrastsecurity/contrastfree.contrastsecurity.com/blob/master/learn/guides/learn-devsec/finding/iast.md",tags:[],version:"current",frontMatter:{title:"IAST"},sidebar:"docsSidebar",previous:{title:"Shading",permalink:"/learn/guides/learn-devsec/development/java/shading"},next:{title:"SBOM",permalink:"/learn/guides/learn-devsec/finding/sbom"}},u={},d=[{value:"Benefits and Drawbacks of IAST",id:"benefits-and-drawbacks-of-iast",level:2},{value:"Benefits",id:"benefits",level:3},{value:"Drawbacks",id:"drawbacks",level:3},{value:"Comparisons to Other Detections",id:"comparisons-to-other-detections",level:2},{value:"Comparison to Static Analysis",id:"comparison-to-static-analysis",level:3},{value:"Comparison to Dynamic Scanners",id:"comparison-to-dynamic-scanners",level:3}],p={toc:d};function m(e){var t=e.components,n=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Interactive Application Security Testing is a technique that embeds monitoring into running software to extract security-relevant information. This technique has a high level of accuracy because it simply observes what the runtime does and reports back."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Contrast Assess")," is an IAST analyzer."),(0,r.kt)("h2",{id:"benefits-and-drawbacks-of-iast"},"Benefits and Drawbacks of IAST"),(0,r.kt)("h3",{id:"benefits"},"Benefits"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"IAST has a high accuracy rate and low false positive rate."),(0,r.kt)("li",{parentName:"ul"},"IAST has a high level of visibility to detect issues anywhere in the code.")),(0,r.kt)("h3",{id:"drawbacks"},"Drawbacks"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"IAST requires code execution, making it better for teams that test their software."),(0,r.kt)("li",{parentName:"ul"},"IAST has a performance impact limited to the environment being tested, making it harder for teams who test in production.")),(0,r.kt)("h2",{id:"comparisons-to-other-detections"},"Comparisons to Other Detections"),(0,r.kt)("h3",{id:"comparison-to-static-analysis"},"Comparison to Static Analysis"),(0,r.kt)("p",null,"Both IAST and Static Analysis provide code-level intelligence."),(0,r.kt)("p",null,"Static Analysis generates results without any code execution. IAST requires code to execute."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Because code does not execute, Static Analysis must make some assumptions about how code is put together. This leads to false positives or negatives in static analysis results."),(0,r.kt)("li",{parentName:"ul"},"IAST has higher accuracy than static analysis because it does not need to make any assumptions."),(0,r.kt)("li",{parentName:"ul"},"IAST can trace moving data through bulk collections list Lists, Sets, and Maps. Static Analysis must make an educated guess to propagate data flow.")),(0,r.kt)("h3",{id:"comparison-to-dynamic-scanners"},"Comparison to Dynamic Scanners"),(0,r.kt)("p",null,"Dynamic Scanners generally test an application with various attack payloads. These scanners rely on messages that come back to the client, basing their detection on a combination of URL, input, and output.",(0,r.kt)("br",null)),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Where a Dynamic Scanner requires input sent backh to a client, IAST can locate a vulnerability regardless of data sent back."),(0,r.kt)("li",{parentName:"ul"},"Dynamic Scanners often lack context when multiple URLs (such as a wildcardh) reach the same code endpoint. By watching the backend, IAST recognizes duplicative work."),(0,r.kt)("li",{parentName:"ul"},"Dynamic Scanners generate their own usage to attack the application. IAST requires something using the application (such as a dynamic scanner, crawler, or user) to generate results.")),(0,r.kt)("p",null,"Dynamic Scanners often face a significant amount of difficulty when evaluating REST or GraphQL applicaions, especially when paired with single page web applications (SPAs). As the scanner modifies data with attack payloads these often encounter difficulty from not knowing the API object format"))}m.isMDXComponent=!0}}]);